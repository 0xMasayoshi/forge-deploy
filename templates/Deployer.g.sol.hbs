// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;
import {Vm} from "forge-std/Vm.sol";
import "forge-std/console.sol";
import "forge-std/StdJson.sol";

struct DeployerDeployment {
    string name;
    address addr;
    string artifactPath;
    string artifactContractName;
    string deploymentContext;
}


contract Deployer {
    Vm constant vm =
        Vm(address(bytes20(uint160(uint256(keccak256("hevm cheat code"))))));

    mapping(string => DeployerDeployment) _namedDeployments;
    DeployerDeployment[] _newDeployments;

    string internal deploymentContext;
    function newDeployments() external view returns (DeployerDeployment[] memory) {
        return _newDeployments;
    }

    function _getDeploymentContext() private returns (string memory context) {
        // no deploymentContext provided we fallback on chainID
        uint256 currentChainID;
        assembly {
            currentChainID := chainid()
        }
        context = vm.envOr("DEPLOYMENT_CONTEXT", vm.toString(currentChainID));
    }


    constructor() {
        deploymentContext = _getDeploymentContext();
        // we read the deployment folder for a .chainId file
        // if the chainId here do not match the current one
        // we are using the same context name on different chain, this is an error
        string memory root = vm.projectRoot();
        string memory path = string.concat(root, "/deployments/", deploymentContext, "/.chainId");
        string memory chainIdExpected;
        try vm.readFile(path) returns (string memory chainId) {
            chainIdExpected = chainId;
            uint256 currentChainID;
            assembly {
                currentChainID := chainid()
            }
            string memory chainIdAsString = vm.toString(currentChainID);
            if (keccak256(bytes(chainIdExpected)) != keccak256(bytes(chainIdAsString))) {
                revert(string.concat("Current chainID: ", chainIdAsString , " But Context '", deploymentContext, "' Already Exists With a Different Chain ID (", chainIdExpected ,")"));
            }
        } catch {
            // unfortunately we have to remove that as we cannot detect whether there is a directory for the deployment 
            // or if the directory is there but the .chainId file is not
            // uint256 currentChainID;
            // assembly {
            //     currentChainID := chainid()
            // }
            // string memory chainIdAsString = vm.toString(currentChainID);
            // if (keccak256(bytes(deploymentContext)) != keccak256(bytes(chainIdAsString))) {
            //     console.log(string.concat("the deployments folder for '", deploymentContext ,"' should have a .chainId file to prevent misusing it by mistake in another chain"));
            // }
        }
        
    }

   
    function _getExistingDeploymentAdress(string memory name) internal returns (address) {
        string memory root = vm.projectRoot();
        string memory path = string.concat(root, "/deployments/", deploymentContext, "/", name, ".json");
        try vm.readFile(path) returns (string memory json) {
            bytes memory addr = stdJson.parseRaw(json, ".address");
            return abi.decode(addr, (address));
        } catch {
            return address(0);
        }
    }

    function has(
        string memory name
    ) public returns (bool) {
        DeployerDeployment memory existing = _namedDeployments[name];
        if (existing.addr != address(0)) {
            return true;
        }
        return _getExistingDeploymentAdress(name) != address(0);
    }

    function getAddress(
        string memory name
    ) public returns (address) {
        DeployerDeployment memory existing = _namedDeployments[name];
        if (existing.addr != address(0)) {
            return existing.addr;
        }
        return _getExistingDeploymentAdress(name);
    }

    // --------------------------------------------------------------------------------------------
    // also expose the save function that can save deployment info to disk
    // --------------------------------------------------------------------------------------------
    function save(
        string memory name,
        address deployed,
        string memory artifactPath,
        string memory artifatContractName
    ) public {
        DeployerDeployment memory deployment = DeployerDeployment({
            name: name,
            addr: address(deployed),
            artifactPath: artifactPath,
            artifactContractName: artifatContractName,
            deploymentContext: deploymentContext
        });
        _namedDeployments[name] = deployment;
        _newDeployments.push(deployment);
        // TODO save artifacts in a temporary folder and inject its path in the output
        // then the sync step can read it to get more info about the deployment, including the exact source, metadata....
        // save(deployment);
    }

    // function save(
    //     string memory name,
    //     address deployed
    // ) public {
    //     DeployerDeployment memory deployment = DeployerDeployment({
    //         name: name,
    //         addr: address(deployed),
    //         artifactPath: "",
    //         artifactContractName: ""
    //     });
    //     _namedDeployments[name] = deployment;
    //     _newDeployments.push(deployment);
    //     // save(deployment);
    // }

    // function save(DeployerDeployment memory deployment) internal {
    //     string memory artifactAsString = vm.readFile(
    //         string(
    //             bytes.concat(
    //                 "out/",
    //                 bytes(deployment.artifactPath),
    //                 "/",
    //                 bytes(deployment.artifactContractName),
    //                 ".json"
    //             )
    //         )
    //     );
    //     bytes memory artifact = vm.parseJson(artifactAsString);
    //     string memory artifactABI = abi.decode(artifact, (string));
    //     // bytes memory artifactABI = vm.parseJson(artifactAsString, "abi");
    //     string memory json = deployment.name;
    //     vm.serializeAddress(json, "address", deployment.addr);
    //     // string memory finalJson = vm.serialize(json, "abi", artifactABI);
    //     // vm.writeFile(
    //     //     string(bytes.concat("./deployments/", bytes(name), ".json")),
    //     //     string(artifactABI)
    //     // );
    //     console.log(string(artifactABI));
    // }
    // --------------------------------------------------------------------------------------------

}
